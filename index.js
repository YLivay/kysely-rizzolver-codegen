#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const ts = require('typescript');

let inputFile = '';
let outputFile = '';
let importFrom = '';
let exportAs = 'rizzolver';
let fksFrom = '';
let defaultGatherDepthStr = '1';

const args = process.argv.slice(2);
if (args.includes('--help') || args.includes('-h')) {
	console.log(`Usage: npx kysely-rizzolver-codegen --schema-from <path> --output <path> [opts]

Options:
  --schema-from <path>  The path the kysely-codegen tool wrote the DB interface to.
  --output <path>       The output file to write this tool's generated code to.
  --import-from <path>  The path that is used in this tool's generated code
                        to import the DB interface from. Defaults to the
                        relative path between the output and input files.
  --fks-from <path>     The path that is used in this tool's generated code
                        to import a function that defines the foreign keys
                        for the database schema. If not provided, no foreign
                        keys will be defined. See README.md for more info.
  --default-gather-depth <depth> The default depth to gather foreign keys when
                        using the gather functions. Defaults to 1.
  --export-as <name>    The name for the exported KyselyRizzolver instance.
                        Defaults to 'rizzolver'.
  --help, -h        Show this help message and exit.
`);
	process.exit(0);
}

for (let i = 0; i < args.length; i++) {
	const arg = args[i];
	const nextArg = args[i + 1];
	switch (arg) {
		case '--schema-from':
			inputFile = nextArg;
			i++;
			break;
		case '--output':
			outputFile = nextArg;
			i++;
			break;
		case '--import-from':
			importFrom = nextArg;
			i++;
			break;
		case '--export-as':
			exportAs = nextArg;
			i++;
			break;
		case '--fks-from':
			fksFrom = nextArg;
			i++;
			break;
		case '--default-gather-depth':
			defaultGatherDepthStr = nextArg;
			i++;
			break;
	}
}

if (!inputFile) {
	throw new Error('--sceham-from must be specified');
}
if (!outputFile) {
	throw new Error('--output must be specified');
}

if (!importFrom) {
	const inputAbs = path.resolve(inputFile);
	const outputAbs = path.resolve(outputFile);
	importFrom = path.relative(path.dirname(outputAbs), inputAbs);
	if (!importFrom.startsWith('../')) {
		importFrom = `./${importFrom}`;
	}
}

let defaultGatherDepth = 0;
try {
	defaultGatherDepth = parseInt(defaultGatherDepthStr, 10);
} catch (e) {
	throw new Error('Invalid --default-gather-depth value');
}

if (defaultGatherDepth < 0 || defaultGatherDepth > 3) {
	throw new Error('--default-gather-depth must be between 0 and 3');
}

const source = ts.createSourceFile(
	inputFile,
	fs.readFileSync(inputFile, 'utf-8'),
	ts.ScriptTarget.ES2015,
	true
);

const dbInterface = source.statements.find(
	(statement) => ts.isInterfaceDeclaration(statement) && statement.name.text === 'DB'
);

if (!dbInterface) {
	throw new Error('Could not find DB interface');
}

const toGenerate = [];
for (const member of dbInterface.members) {
	if (ts.isPropertySignature(member)) {
		const value = member.type;
		if (ts.isTypeReferenceNode(value)) {
			const typeName = value.typeName.text;
			const tableType = source.statements.find(
				(statement) => ts.isInterfaceDeclaration(statement) && statement.name.text === typeName
			);
			if (!tableType) {
				throw new Error('Could not find the type for ' + typeName);
			}
			const columns = tableType.members
				.filter((member) => ts.isPropertySignature(member))
				.map((column) => column.name.text);
			toGenerate.push({ table: member.name.text, columns: columns });
		}
	}
}

if (toGenerate.length > 0) {
	let result = `// This file was generated by kysely-rizzolver-codegen. Do not edit it manually.

import type { Selectable } from 'kysely';
import { KyselyRizzolver } from 'kysely-rizzolver';
import type {
	FetchResult as _FetchResult,
	FetchOneResult as _FetchOneResult,
	FetchOneXResult as _FetchOneXResult,
	FetchSomeResult as _FetchSomeResult,
	FkGatherResult,
	FkGatherOneResult,
	FkGatherOneXResult,
	FkGatherSomeResult,
	ModelFkInstance,
	ValidFkDepth
} from 'kysely-rizzolver';
import type { DB } from '${importFrom}';
{{fksImport}}

export const ${exportAs} = KyselyRizzolver.builder<DB>()
	{{rizzolverBody}}

export type DBFk = typeof ${exportAs}._types.dbfk;

// Fetch types
export type FetchResult<
	Table extends keyof DB & string,
	Shape extends Partial<Selectable<DB[Table]>> = Selectable<DB[Table]>
> = _FetchResult<DB, Table, Shape>;

export type FetchOneResult<
	Table extends keyof DB & string,
	Shape extends Partial<Selectable<DB[Table]>> = Selectable<DB[Table]>
> = _FetchOneResult<DB, Table, Shape>;

export type FetchOneXResult<
	Table extends keyof DB & string,
	Shape extends Partial<Selectable<DB[Table]>> = Selectable<DB[Table]>
> = _FetchOneXResult<DB, Table, Shape>;

export type FetchSomeResult<
	Table extends keyof DB & string,
	Shape extends Partial<Selectable<DB[Table]>> = Selectable<DB[Table]>
> = _FetchSomeResult<DB, Table, Shape>;

// Gathered model types
export type ModelInstance<
	Table extends keyof DB & string,
	Depth extends ValidFkDepth = ValidFkDepth
> = ModelFkInstance<DBFk, Table, Depth>;

export type ModelBare<Table extends keyof DB & string> = ModelInstance<Table, 0>;

export type ModelGathered<
	Table extends keyof DB & string,
	Depth extends Exclude<ValidFkDepth, 0> = Exclude<ValidFkDepth, 0>
> = ModelInstance<Table, Depth>;

// Gather result types
export type GatherResult<
	Table extends keyof DB & string,
	Depth extends ValidFkDepth = ${defaultGatherDepth}
> = FkGatherResult<DBFk, Table, Depth>;

export type GatherOneResult<
	Table extends keyof DB & string,
	Depth extends ValidFkDepth = ${defaultGatherDepth}
> = FkGatherOneResult<DBFk, Table, Depth>;

export type GatherOneXResult<
	Table extends keyof DB & string,
	Depth extends ValidFkDepth = ${defaultGatherDepth}
> = FkGatherOneXResult<DBFk, Table, Depth>;

export type GatherSomeResult<
	Table extends keyof DB & string,
	Depth extends ValidFkDepth = ${defaultGatherDepth}
> = FkGatherSomeResult<DBFk, Table, Depth>;
`;

	const rizzolverTables = [];
	for (const { table, columns } of toGenerate) {
		const columnsStr = columns.map((column) => `'${column}'`).join(', ');
		rizzolverTables.push(`.table('${table}', [${columnsStr}] as const)`);
	}

	let rizzolverBody = rizzolverTables.join('\n\t') + '\n';
	rizzolverBody += `\t.defaultGatherDepth(${defaultGatherDepth})\n`;

	if (fksFrom) {
		result = result.replace('{{fksImport}}\n', `import defineFks from '${fksFrom}';\n`);
		rizzolverBody += `\t.build(defineFks);`;
	} else {
		result = result.replace('{{fksImport}}\n', '');
		rizzolverBody += `\t.build();`;
	}

	result = result.replace('{{rizzolverBody}}', rizzolverBody);

	fs.writeFileSync(outputFile, result);
}
